// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/ayankousky/exchange-data-importer/internal/infrastructure/exchanges"
	"sync"
)

// ExchangeMock is a mock implementation of exchanges.Exchange.
//
//	func TestSomethingThatUsesExchange(t *testing.T) {
//
//		// make and configure a mocked exchanges.Exchange
//		mockedExchange := &ExchangeMock{
//			FetchTickersFunc: func(ctx context.Context) ([]exchanges.Ticker, error) {
//				panic("mock out the FetchTickers method")
//			},
//			GetNameFunc: func() string {
//				panic("mock out the GetName method")
//			},
//			SubscribeLiquidationsFunc: func(ctx context.Context) (<-chan exchanges.Liquidation, <-chan error) {
//				panic("mock out the SubscribeLiquidations method")
//			},
//		}
//
//		// use mockedExchange in code that requires exchanges.Exchange
//		// and then make assertions.
//
//	}
type ExchangeMock struct {
	// FetchTickersFunc mocks the FetchTickers method.
	FetchTickersFunc func(ctx context.Context) ([]exchanges.Ticker, error)

	// GetNameFunc mocks the GetName method.
	GetNameFunc func() string

	// SubscribeLiquidationsFunc mocks the SubscribeLiquidations method.
	SubscribeLiquidationsFunc func(ctx context.Context) (<-chan exchanges.Liquidation, <-chan error)

	// calls tracks calls to the methods.
	calls struct {
		// FetchTickers holds details about calls to the FetchTickers method.
		FetchTickers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetName holds details about calls to the GetName method.
		GetName []struct {
		}
		// SubscribeLiquidations holds details about calls to the SubscribeLiquidations method.
		SubscribeLiquidations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockFetchTickers          sync.RWMutex
	lockGetName               sync.RWMutex
	lockSubscribeLiquidations sync.RWMutex
}

// FetchTickers calls FetchTickersFunc.
func (mock *ExchangeMock) FetchTickers(ctx context.Context) ([]exchanges.Ticker, error) {
	if mock.FetchTickersFunc == nil {
		panic("ExchangeMock.FetchTickersFunc: method is nil but Exchange.FetchTickers was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetchTickers.Lock()
	mock.calls.FetchTickers = append(mock.calls.FetchTickers, callInfo)
	mock.lockFetchTickers.Unlock()
	return mock.FetchTickersFunc(ctx)
}

// FetchTickersCalls gets all the calls that were made to FetchTickers.
// Check the length with:
//
//	len(mockedExchange.FetchTickersCalls())
func (mock *ExchangeMock) FetchTickersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetchTickers.RLock()
	calls = mock.calls.FetchTickers
	mock.lockFetchTickers.RUnlock()
	return calls
}

// ResetFetchTickersCalls reset all the calls that were made to FetchTickers.
func (mock *ExchangeMock) ResetFetchTickersCalls() {
	mock.lockFetchTickers.Lock()
	mock.calls.FetchTickers = nil
	mock.lockFetchTickers.Unlock()
}

// GetName calls GetNameFunc.
func (mock *ExchangeMock) GetName() string {
	if mock.GetNameFunc == nil {
		panic("ExchangeMock.GetNameFunc: method is nil but Exchange.GetName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetName.Lock()
	mock.calls.GetName = append(mock.calls.GetName, callInfo)
	mock.lockGetName.Unlock()
	return mock.GetNameFunc()
}

// GetNameCalls gets all the calls that were made to GetName.
// Check the length with:
//
//	len(mockedExchange.GetNameCalls())
func (mock *ExchangeMock) GetNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetName.RLock()
	calls = mock.calls.GetName
	mock.lockGetName.RUnlock()
	return calls
}

// ResetGetNameCalls reset all the calls that were made to GetName.
func (mock *ExchangeMock) ResetGetNameCalls() {
	mock.lockGetName.Lock()
	mock.calls.GetName = nil
	mock.lockGetName.Unlock()
}

// SubscribeLiquidations calls SubscribeLiquidationsFunc.
func (mock *ExchangeMock) SubscribeLiquidations(ctx context.Context) (<-chan exchanges.Liquidation, <-chan error) {
	if mock.SubscribeLiquidationsFunc == nil {
		panic("ExchangeMock.SubscribeLiquidationsFunc: method is nil but Exchange.SubscribeLiquidations was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSubscribeLiquidations.Lock()
	mock.calls.SubscribeLiquidations = append(mock.calls.SubscribeLiquidations, callInfo)
	mock.lockSubscribeLiquidations.Unlock()
	return mock.SubscribeLiquidationsFunc(ctx)
}

// SubscribeLiquidationsCalls gets all the calls that were made to SubscribeLiquidations.
// Check the length with:
//
//	len(mockedExchange.SubscribeLiquidationsCalls())
func (mock *ExchangeMock) SubscribeLiquidationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSubscribeLiquidations.RLock()
	calls = mock.calls.SubscribeLiquidations
	mock.lockSubscribeLiquidations.RUnlock()
	return calls
}

// ResetSubscribeLiquidationsCalls reset all the calls that were made to SubscribeLiquidations.
func (mock *ExchangeMock) ResetSubscribeLiquidationsCalls() {
	mock.lockSubscribeLiquidations.Lock()
	mock.calls.SubscribeLiquidations = nil
	mock.lockSubscribeLiquidations.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ExchangeMock) ResetCalls() {
	mock.lockFetchTickers.Lock()
	mock.calls.FetchTickers = nil
	mock.lockFetchTickers.Unlock()

	mock.lockGetName.Lock()
	mock.calls.GetName = nil
	mock.lockGetName.Unlock()

	mock.lockSubscribeLiquidations.Lock()
	mock.calls.SubscribeLiquidations = nil
	mock.lockSubscribeLiquidations.Unlock()
}
